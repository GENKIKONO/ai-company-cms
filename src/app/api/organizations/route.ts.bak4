// Partner-Only API: /api/organizations
// ä»£ç†åº—ï¼ˆãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ï¼‰ã®ã¿ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªä¼æ¥­ç®¡ç†API
import { NextRequest, NextResponse } from 'next/server';
import { env } from '@/lib/env';
import { z } from 'zod';
import {
  requireAuth,
  requirePartnerAccess,
  type AuthContext
} from '@/lib/api/auth-middleware';
import {
  handleApiError,
  validationError,
  conflictError,
  notFoundError,
  handleZodError,
  createErrorResponse
} from '@/lib/api/error-responses';
import { normalizeOrganizationPayload } from '@/lib/utils/data-normalization';
import { normalizeForInsert, findEmptyDateFields } from '@/lib/utils/payload-normalizer';
import { buildOrgInsert } from '@/lib/utils/org-whitelist';
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Organization, OrganizationFormData } from '@/types/database';
import { logger } from '@/lib/log';
import {
  organizationCreateSchema,
  organizationUpdateSchema,
  type OrganizationCreate
} from '@/lib/schemas/organization';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
export const revalidate = 0;
export const fetchCache = 'force-no-store';

// GET - ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ãŒç®¡ç†å¯èƒ½ãªä¼æ¥­ãƒªã‚¹ãƒˆã‚’å–å¾—
export async function GET(request: NextRequest) {
  try {
    // çµ±ä¸€èªè¨¼ãƒã‚§ãƒƒã‚¯
    const authResult = await requireAuth(request);
    if (authResult instanceof NextResponse) {
      return authResult;
    }
    
    // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚¢ã‚¯ã‚»ã‚¹ãƒã‚§ãƒƒã‚¯
    const partnerCheck = requirePartnerAccess(authResult as AuthContext);
    if (partnerCheck) {
      return partnerCheck;
    }
    
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = Math.min(parseInt(searchParams.get('limit') || '24'), 100);
    const industry = searchParams.get('industry');
    const region = searchParams.get('region');
    const size = searchParams.get('size');
    const search = searchParams.get('q');
    const status = searchParams.get('status');
    const is_published = searchParams.get('is_published');

    const offset = (page - 1) * limit;

    const cookieStore = await cookies();
    const supabase = createServerClient(
      env.SUPABASE_URL,
      env.SUPABASE_ANON_KEY,
      {
        cookies: {
          getAll() {
            return cookieStore.getAll();
          },
          setAll(cookiesToSet) {
            try {
              cookiesToSet.forEach(({ name, value, options }) =>
                cookieStore.set(name, value, options)
              );
            } catch (error) {
              // Server Component ã§ã® cookie è¨­å®šã‚¨ãƒ©ãƒ¼ã‚’ãƒãƒ³ãƒ‰ãƒ«
            }
          },
        },
      }
    );
    
    let query = supabase
      .from('organizations')
      .select('*', { count: 'exact' });
    
    // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã®å ´åˆã€ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªä¼æ¥­ã®ã¿è¡¨ç¤º
    if ((authResult as AuthContext).userAccess.flow === 'partner' && (authResult as AuthContext).userAccess.accessibleOrgIds.length > 0) {
      query = query.in('id', (authResult as AuthContext).userAccess.accessibleOrgIds);
    }
    // ç®¡ç†è€…ã®å ´åˆã¯å…¨ä¼æ¥­ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãªã—ï¼‰

    // Apply filters
    if (is_published !== null && is_published !== undefined) {
      query = query.eq('is_published', is_published === 'true');
    }
    
    if (status) {
      const statuses = status.split(',');
      query = query.in('status', statuses);
    }
    
    if (industry) {
      const industries = industry.split(',');
      query = query.overlaps('industries', industries);
    }

    if (region) {
      const regions = region.split(',');
      query = query.in('address_region', regions);
    }

    if (size) {
      const sizes = size.split(',');
      query = query.in('size', sizes);
    }

    if (search) {
      query = query.or(`name.ilike.%${search}%,description.ilike.%${search}%,keywords.ilike.%${search}%`);
    }

    const { data, error, count } = await query
      .order('updated_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) {
      logger.error('Database error', { data: error instanceof Error ? error : new Error(String(error)));
      return handleApiError(error);
    }

    return NextResponse.json(
      {
        data: data || [],
        meta: {
          total: count || 0,
          page,
          limit,
          has_more: (count || 0) > offset + limit,
        },
      },
      {
        headers: {
          'Cache-Control': 'no-store, must-revalidate'
        }
      }
    );

  } catch (error) {
    logger.error('[GET /api/organizations] Unexpected error', { data: error instanceof Error ? error : new Error(String(error)));
    return handleApiError(error);
  }
}

// ãƒ‡ãƒ¼ã‚¿æ­£è¦åŒ–ã¯çµ±ä¸€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨

// POST - ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ãŒæ–°ã—ã„ä¼æ¥­ã‚’ä½œæˆ
export async function POST(request: NextRequest) {
  try {
    // çµ±ä¸€èªè¨¼ãƒã‚§ãƒƒã‚¯
    const authResult = await requireAuth(request);
    if (authResult instanceof NextResponse) {
      return authResult;
    }
    
    // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚¢ã‚¯ã‚»ã‚¹ãƒã‚§ãƒƒã‚¯
    const partnerCheck = requirePartnerAccess(authResult as AuthContext);
    if (partnerCheck) {
      return partnerCheck;
    }
    
    const rawBody = await request.json();

    // çµ±ä¸€ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    let validatedData: OrganizationCreate;
    try {
      validatedData = organizationCreateSchema.parse(rawBody);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return handleZodError(error);
      }
      throw error;
    }

    // ãƒ‡ãƒ¼ã‚¿ã®æ­£è¦åŒ–
    const normalizedBody = normalizeOrganizationPayload(validatedData);

    const cookieStore = await cookies();
    const supabase = createServerClient(
      env.SUPABASE_URL,
      env.SUPABASE_ANON_KEY,
      {
        cookies: {
          getAll() {
            return cookieStore.getAll();
          },
          setAll(cookiesToSet) {
            try {
              cookiesToSet.forEach(({ name, value, options }) =>
                cookieStore.set(name, value, options)
              );
            } catch (error) {
              // Server Component ã§ã® cookie è¨­å®šã‚¨ãƒ©ãƒ¼ã‚’ãƒãƒ³ãƒ‰ãƒ«
            }
          },
        },
      }
    );
    
    // slugã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    // slugãŒæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    if (validatedData.slug) {
      const { data: slugCheck } = await supabase
        .from('organizations')
        .select('id')
        .eq('slug', validatedData.slug)
        .single();

      if (slugCheck) {
        return conflictError('Organization', 'slug');
      }
    }

    // æ³•äººç•ªå·ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    if (validatedData.corporate_number) {
      const { data: corporateNumberCheck } = await supabase
        .from('organizations')
        .select('id, name')
        .eq('corporate_number', validatedData.corporate_number)
        .single();

      if (corporateNumberCheck) {
        return NextResponse.json(
          {
            error: 'CORPORATE_NUMBER_EXISTS',
            message: `æ³•äººç•ªå· ${validatedData.corporate_number} ã¯æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™ï¼ˆä¼æ¥­å: ${corporateNumberCheck.name}ï¼‰`,
            field: 'corporate_number'
          },
          { status: 409 }
        );
      }
    }

    let organizationData: Partial<Organization> = {
      ...normalizedBody,
      created_by: (authResult as AuthContext).user.id,
      status: normalizedBody.status || 'public_unverified', // P0: æ–°è¦çµ„ç¹”ã¯é™å®šå…¬é–‹ã§é–‹å§‹
      is_published: false, // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ä½œæˆæ™‚ã¯åˆæœŸéå…¬é–‹
    };

    // ğŸš€ GPTæ’ä¹…å¯¾ç­–: ç©ºæ–‡å­—ã®æ—¥ä»˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ¤œå‡ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    const emptyDates = findEmptyDateFields(organizationData as any, ['established_at']);
    if (emptyDates.length) {
      logger.warn('âš ï¸ [/api/organizations] Empty date fields detected, { data: normalizing', emptyDates });
    }

    // ğŸš€ GPTæ’ä¹…å¯¾ç­–: INSERTç›´å‰ã®ç¢ºå®Ÿãªæ­£è¦åŒ–
    organizationData = normalizeForInsert(organizationData as any, {
      dateFields: ['established_at'], // DBã«ã‚ã‚‹æ—¥ä»˜ã‚«ãƒ©ãƒ ã‚’åˆ—æŒ™
    });

    logger.info('Normalized organization data for INSERT', { 
      component: '/api/organizations',
      organizationData: JSON.stringify(organizationData, null, 2)
    });

    // âœ… æœ€çµ‚ã‚¬ãƒ¼ãƒ‰ï¼šæ—¥ä»˜ã¯ç©ºæ–‡å­—ã®å¯èƒ½æ€§ãŒå°‘ã—ã§ã‚‚ã‚ã‚Œã° null ã‚’æ˜ç¤ºã—ã¦é€ã‚‹
    const finalGuardDateFields = ['established_at']; // å¿…è¦ã«å¿œã˜ã¦ä»–ã®DATEå‹ã‚‚è¿½è¨˜
    for (const f of finalGuardDateFields) {
      const v = (organizationData as any)[f];
      if (v === '' || v === undefined) {
        (organizationData as any)[f] = null;   // â† ã‚­ãƒ¼ã‚’å‰Šé™¤ã›ãš null ã‚’æ˜ç¤º
        logger.debug('Final guard set field to null', { 
          component: '/api/organizations',
          field: f,
          previousValue: JSON.stringify(v)
        });
      }
    }

    // ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆå‡¦ç†ã®å‰ã«ã“ã®ä¿®æ­£ã‚’è¡Œã†
    const insertPayload = buildOrgInsert(organizationData);
    logger.debug('API/organizations INSERT payload (final)', insertPayload);

    const { data, error } = await supabase
      .from('organizations')
      .insert([insertPayload])
      .select()
      .single();

    if (error) {
      logger.error('Database error', { data: error instanceof Error ? error : new Error(String(error)));
      return handleApiError(error);
    }

    return NextResponse.json(
      { 
        data: {
          id: data.id,
          name: data.name,
          slug: data.slug,
          status: data.status
        },
        message: 'Organization created successfully'
      }, 
      { 
        status: 201,
        headers: {
          'Cache-Control': 'no-store, must-revalidate'
        }
      }
    );

  } catch (error) {
    logger.error('[POST /api/organizations] Unexpected error', { data: error instanceof Error ? error : new Error(String(error)));
    return handleApiError(error);
  }
}