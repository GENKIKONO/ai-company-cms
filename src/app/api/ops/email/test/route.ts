import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { generateAuthLink } from '@/lib/auth/generate-link';
import { sendHtmlEmail } from '@/lib/email/resend-client';
import { supabaseAdmin } from '@/lib/supabase-admin-client';
<<<<<<< HEAD
=======
import { APP_URL } from '@/lib/utils/env';
>>>>>>> release/p0-freeze

// Request validation schema
const EmailTestSchema = z.object({
  testEmail: z.string().email('Valid test email required'),
  tests: z.array(z.enum(['resend_direct', 'supabase_direct', 'dual_path', 'auth_flow'])).default(['resend_direct', 'supabase_direct', 'dual_path']),
  skipActualSend: z.boolean().default(false) // For testing without actually sending emails
});

// Test result interface
interface TestResult {
  test: string;
  success: boolean;
  duration: number;
  details?: any;
  error?: string;
  provider?: string;
}

interface TestReport {
  success: boolean;
  summary: {
    total: number;
    passed: number;
    failed: number;
    skipped: number;
  };
  results: TestResult[];
  requestId: string;
  timestamp: string;
  environment: {
    hasResendKey: boolean;
    hasSupabaseKeys: boolean;
    appUrl: string;
  };
}

export async function POST(request: NextRequest) {
  // Guard: Check if admin keys are configured (prevent unauthorized access)
  if (!process.env.SUPABASE_SERVICE_ROLE_KEY || !process.env.NEXT_PUBLIC_SUPABASE_URL) {
    return NextResponse.json(
      { 
        error: 'Service unavailable - Admin configuration not found',
        code: 'service_unavailable'
      },
      { status: 503 }
    );
  }

  const requestId = crypto.randomUUID();
  const timestamp = new Date().toISOString();
  
  console.info({
    event: 'email_test_start',
    requestId,
    timestamp
  });

  try {
    // Parse and validate request
    const body = await request.json();
    const validationResult = EmailTestSchema.safeParse(body);

    if (!validationResult.success) {
      const validationErrors = validationResult.error.errors.map(err => 
        `${err.path.join('.')}: ${err.message}`
      ).join(', ');

      return NextResponse.json(
        { 
          success: false, 
          error: 'Validation failed',
          details: validationErrors,
          requestId 
        },
        { status: 400 }
      );
    }

    const { testEmail, tests, skipActualSend } = validationResult.data;
    const results: TestResult[] = [];

    // Environment check
    const environment = {
      hasResendKey: !!(process.env.RESEND_API_KEY && process.env.RESEND_API_KEY !== 'dummy-key-for-build'),
      hasSupabaseKeys: !!(process.env.SUPABASE_SERVICE_ROLE_KEY && process.env.NEXT_PUBLIC_SUPABASE_URL),
<<<<<<< HEAD
      appUrl: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
=======
      appUrl: APP_URL
>>>>>>> release/p0-freeze
    };

    console.info({
      event: 'email_test_environment',
      requestId,
      environment,
      testEmail: testEmail.replace(/(.{2}).*@/, '$1***@'), // Mask email for privacy
      testsRequested: tests,
      skipActualSend
    });

    // Test 1: Resend Direct Test
    if (tests.includes('resend_direct')) {
      const startTime = Date.now();
      
      if (!environment.hasResendKey) {
        results.push({
          test: 'resend_direct',
          success: false,
          duration: Date.now() - startTime,
          error: 'RESEND_API_KEY not configured',
          provider: 'resend'
        });
      } else {
        try {
          const testHtml = `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2>ðŸ§ª Resend Direct Test</h2>
              <p>This is a test email sent directly via Resend API.</p>
              <p><strong>Test ID:</strong> ${requestId}</p>
              <p><strong>Timestamp:</strong> ${timestamp}</p>
              <p><strong>Test Type:</strong> resend_direct</p>
              <hr style="margin: 20px 0; border: none; border-top: 1px solid #eee;">
              <p style="color: #666; font-size: 12px;">
                This email was generated by the AIO Hub email testing system.
              </p>
            </div>
          `;

          let emailResult;
          if (skipActualSend) {
            emailResult = { success: true, messageId: 'test-skip-' + requestId };
          } else {
            emailResult = await sendHtmlEmail({
              to: testEmail,
              subject: `ðŸ§ª Resend Direct Test - ${requestId}`,
              html: testHtml,
              requestId
            });
          }

          results.push({
            test: 'resend_direct',
            success: emailResult.success,
            duration: Date.now() - startTime,
            details: {
              messageId: emailResult.messageId,
              skipped: skipActualSend
            },
            provider: 'resend',
            error: emailResult.success ? undefined : emailResult.error
          });

        } catch (error) {
          results.push({
            test: 'resend_direct',
            success: false,
            duration: Date.now() - startTime,
            error: error instanceof Error ? error.message : 'Unknown error',
            provider: 'resend'
          });
        }
      }
    }

    // Test 2: Supabase Direct Test
    if (tests.includes('supabase_direct')) {
      const startTime = Date.now();
      
      if (!environment.hasSupabaseKeys) {
        results.push({
          test: 'supabase_direct',
          success: false,
          duration: Date.now() - startTime,
          error: 'Supabase keys not configured',
          provider: 'supabase'
        });
      } else {
        try {
          let supabaseResult;
          if (skipActualSend) {
            supabaseResult = { 
              success: true, 
              message: 'Test skipped - Supabase auth would be called here',
              data: { user: null, session: null }
            };
          } else {
            // Test Supabase email by attempting to generate an auth link
            // This tests the Supabase Admin API connectivity and email generation capability
            const linkResult = await generateAuthLink({
              email: testEmail,
              type: 'magiclink',
              requestId
            });

            supabaseResult = {
              success: linkResult.success,
              message: linkResult.success ? 'Supabase auth link generated successfully' : linkResult.error,
              data: linkResult.success ? { url: '***masked***' } : undefined
            };
          }

          results.push({
            test: 'supabase_direct',
            success: supabaseResult.success,
            duration: Date.now() - startTime,
            details: {
              message: supabaseResult.message,
              skipped: skipActualSend
            },
            provider: 'supabase',
            error: supabaseResult.success ? undefined : supabaseResult.message
          });

        } catch (error) {
          results.push({
            test: 'supabase_direct',
            success: false,
            duration: Date.now() - startTime,
            error: error instanceof Error ? error.message : 'Unknown error',
            provider: 'supabase'
          });
        }
      }
    }

    // Test 3: Dual-Path Test (Supabase + Resend Backup)
    if (tests.includes('dual_path')) {
      const startTime = Date.now();
      
      try {
        const supabaseSuccess = environment.hasSupabaseKeys;
        const resendSuccess = environment.hasResendKey;

        if (!supabaseSuccess && !resendSuccess) {
          results.push({
            test: 'dual_path',
            success: false,
            duration: Date.now() - startTime,
            error: 'Neither Supabase nor Resend is configured',
            provider: 'dual'
          });
        } else {
          // Simulate the dual-path flow
          let primaryResult = { success: false, provider: 'none' };
          let backupResult = { success: false, provider: 'none' };

          // Primary: Supabase
          if (supabaseSuccess) {
            try {
              if (skipActualSend) {
                primaryResult = { success: true, provider: 'supabase' };
              } else {
                const linkResult = await generateAuthLink({
                  email: testEmail,
                  type: 'signup',
                  requestId
                });
                primaryResult = { success: linkResult.success, provider: 'supabase' };
              }
            } catch (error) {
              primaryResult = { success: false, provider: 'supabase' };
            }
          }

          // Backup: Resend (always attempt, regardless of primary success)
          if (resendSuccess) {
            try {
              if (skipActualSend) {
                backupResult = { success: true, provider: 'resend' };
              } else {
                const emailResult = await sendHtmlEmail({
                  to: testEmail,
                  subject: `ðŸ§ª Dual-Path Backup Test - ${requestId}`,
                  html: `
                    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                      <h2>ðŸ§ª Dual-Path Backup Test</h2>
                      <p>This is a backup email sent via Resend as part of dual-path testing.</p>
                      <p><strong>Test ID:</strong> ${requestId}</p>
                      <p><strong>Primary Result:</strong> ${primaryResult.success ? 'Success' : 'Failed'} (${primaryResult.provider})</p>
                      <p><strong>Test Type:</strong> dual_path_backup</p>
                    </div>
                  `,
                  requestId
                });
                backupResult = { success: emailResult.success, provider: 'resend' };
              }
            } catch (error) {
              backupResult = { success: false, provider: 'resend' };
            }
          }

          const overallSuccess = primaryResult.success || backupResult.success;

          results.push({
            test: 'dual_path',
            success: overallSuccess,
            duration: Date.now() - startTime,
            details: {
              primary: primaryResult,
              backup: backupResult,
              strategy: 'supabase_primary_resend_backup',
              skipped: skipActualSend
            },
            provider: 'dual'
          });
        }

      } catch (error) {
        results.push({
          test: 'dual_path',
          success: false,
          duration: Date.now() - startTime,
          error: error instanceof Error ? error.message : 'Unknown error',
          provider: 'dual'
        });
      }
    }

    // Test 4: Full Auth Flow Test
    if (tests.includes('auth_flow')) {
      const startTime = Date.now();
      
      try {
        // Test the complete auth flow by calling our resend-confirmation API
        const authFlowResponse = await fetch(`${environment.appUrl}/api/auth/resend-confirmation`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            email: testEmail,
            type: 'signup'
          }),
        });

        const authFlowResult = await authFlowResponse.json();

        results.push({
          test: 'auth_flow',
          success: authFlowResult.success,
          duration: Date.now() - startTime,
          details: {
            apiStatus: authFlowResponse.status,
            response: authFlowResult,
            endpointTested: '/api/auth/resend-confirmation'
          },
          provider: 'api',
          error: authFlowResult.success ? undefined : authFlowResult.error
        });

      } catch (error) {
        results.push({
          test: 'auth_flow',
          success: false,
          duration: Date.now() - startTime,
          error: error instanceof Error ? error.message : 'Unknown error',
          provider: 'api'
        });
      }
    }

    // Generate summary
    const summary = {
      total: results.length,
      passed: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      skipped: 0
    };

    const overallSuccess = summary.failed === 0 && summary.total > 0;

    const report: TestReport = {
      success: overallSuccess,
      summary,
      results,
      requestId,
      timestamp,
      environment
    };

    console.info({
      event: 'email_test_complete',
      requestId,
      summary,
      overallSuccess,
      timestamp
    });

    return NextResponse.json(report, { status: 200 });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    
    console.error({
      event: 'email_test_error',
      requestId,
      error: errorMessage,
      timestamp
    });

    return NextResponse.json(
      {
        success: false,
        error: 'Internal server error',
        requestId
      },
      { status: 500 }
    );
  }
}