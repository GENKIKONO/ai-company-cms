import { logger } from '@/lib/utils/logger';
import type { 
  Metric, 
  Alert, 
  AlertRule, 
  SystemHealth, 
  MonitoringFilters,
  MetricType,
  MonitoringSource,
  AlertSeverity 
} from './types';

export interface MonitoringClientConfig {
  enabled: boolean;
  apiUrl?: string;
  apiKey?: string;
  defaultLabels?: Record<string, string>;
  batchSize?: number;
  flushInterval?: number; // milliseconds
}

export class MonitoringClient {
  private config: MonitoringClientConfig;
  private metricBuffer: Metric[] = [];
  private flushTimer?: NodeJS.Timeout;

  constructor(config: MonitoringClientConfig) {
    this.config = {
      batchSize: 100,
      flushInterval: 10000, // 10 seconds
      ...config
    };

    if (this.config.enabled && this.config.flushInterval) {
      this.startPeriodicFlush();
    }
  }

  // Metric Collection Methods
  async recordMetric(
    name: string,
    value: number,
    type: MetricType = 'gauge',
    labels: Record<string, string> = {},
    unit: string = 'count'
  ): Promise<void> {
    if (!this.config.enabled) return;

    const metric: Metric = {
      id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name,
      type,
      value,
      unit,
      labels: { ...this.config.defaultLabels, ...labels },
      timestamp: new Date().toISOString(),
      source: 'application'
    };

    this.metricBuffer.push(metric);

    if (this.metricBuffer.length >= (this.config.batchSize || 100)) {
      await this.flushMetrics();
    }
  }

  async incrementCounter(
    name: string,
    labels: Record<string, string> = {},
    value: number = 1
  ): Promise<void> {
    return this.recordMetric(name, value, 'counter', labels);
  }

  async setGauge(
    name: string,
    value: number,
    labels: Record<string, string> = {},
    unit: string = 'count'
  ): Promise<void> {
    return this.recordMetric(name, value, 'gauge', labels, unit);
  }

  async recordHistogram(
    name: string,
    value: number,
    labels: Record<string, string> = {},
    unit: string = 'seconds'
  ): Promise<void> {
    return this.recordMetric(name, value, 'histogram', labels, unit);
  }

  // Performance Monitoring
  async recordResponseTime(
    endpoint: string,
    duration: number,
    statusCode: number,
    organizationId?: string
  ): Promise<void> {
    const labels: Record<string, string> = {
      endpoint,
      status_code: statusCode.toString(),
      status_class: `${Math.floor(statusCode / 100)}xx`
    };

    if (organizationId) {
      labels.organization_id = organizationId;
    }

    await this.recordHistogram('http_request_duration', duration / 1000, labels, 'seconds');
    await this.incrementCounter('http_requests_total', labels);

    if (statusCode >= 400) {
      await this.incrementCounter('http_errors_total', labels);
    }
  }

  async recordDatabaseQuery(
    query: string,
    duration: number,
    success: boolean,
    organizationId?: string
  ): Promise<void> {
    const labels: Record<string, string> = {
      query_type: this.extractQueryType(query),
      success: success.toString()
    };

    if (organizationId) {
      labels.organization_id = organizationId;
    }

    await this.recordHistogram('database_query_duration', duration / 1000, labels, 'seconds');
    await this.incrementCounter('database_queries_total', labels);

    if (!success) {
      await this.incrementCounter('database_errors_total', labels);
    }
  }

  async recordUserActivity(
    action: string,
    userId: string,
    organizationId: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    const labels = {
      action,
      organization_id: organizationId
    };

    await this.incrementCounter('user_activity_total', labels);

    // Log significant events for audit trail
    if (metadata) {
      logger.info(`User activity: ${action}`, {
        user_id: userId,
        organization_id: organizationId,
        ...metadata
      });
    }
  }

  // Alert Management
  async triggerAlert(
    ruleName: string,
    severity: AlertSeverity,
    message: string,
    value: number,
    threshold: number,
    labels: Record<string, string> = {}
  ): Promise<void> {
    if (!this.config.enabled) return;

    // TODO: Implement actual alert creation
    // This would create an alert record and send notifications
    
    const alert: Omit<Alert, 'id' | 'rule_id' | 'created_at' | 'updated_at'> = {
      name: ruleName,
      description: message,
      severity,
      status: 'active',
      source: 'application',
      triggered_at: new Date().toISOString(),
      current_value: value,
      threshold_value: threshold,
      metric_name: ruleName,
      labels
    };

    logger.warn(`Alert triggered: ${ruleName}`, {
      severity,
      current_value: value,
      threshold: threshold,
      labels
    });

    // In a real implementation, this would:
    // 1. Store the alert in the database
    // 2. Check notification rules
    // 3. Send notifications via configured channels
    // 4. Update monitoring dashboards
  }

  // System Health
  async getSystemHealth(): Promise<SystemHealth> {
    // TODO: Implement actual health checks
    // This would query various system metrics and external services
    
    const mockHealth: SystemHealth = {
      overall_status: 'healthy',
      last_updated: new Date().toISOString(),
      components: [
        {
          name: 'API Server',
          status: 'operational',
          response_time: 45,
          error_rate: 0.1,
          last_check: new Date().toISOString()
        },
        {
          name: 'Database',
          status: 'operational',
          response_time: 12,
          error_rate: 0.0,
          last_check: new Date().toISOString()
        },
        {
          name: 'Cache',
          status: 'operational',
          response_time: 3,
          error_rate: 0.0,
          last_check: new Date().toISOString()
        }
      ],
      uptime_percentage: 99.95,
      response_time_avg: 125,
      error_rate: 0.05,
      active_alerts: 0,
      cpu_usage: 35,
      memory_usage: 68,
      disk_usage: 42,
      external_services: [
        {
          name: 'Supabase',
          status: 'operational',
          response_time: 89,
          last_check: new Date().toISOString()
        },
        {
          name: 'Vercel',
          status: 'operational',
          response_time: 23,
          last_check: new Date().toISOString()
        }
      ]
    };

    return mockHealth;
  }

  // Data Retrieval
  async getMetrics(
    metricName: string,
    timeRange: { start: string; end: string },
    labels: Record<string, string> = {}
  ): Promise<Metric[]> {
    if (!this.config.enabled) return [];

    // TODO: Implement actual metric retrieval
    // This would query the metrics storage backend
    
    logger.info('Retrieving metrics', {
      metric_name: metricName,
      time_range: timeRange,
      labels
    });

    return []; // Return empty array for now
  }

  async getAlerts(filters: MonitoringFilters): Promise<Alert[]> {
    if (!this.config.enabled) return [];

    // TODO: Implement actual alert retrieval
    // This would query the alerts database
    
    logger.info('Retrieving alerts', { data: { filters } });

    return []; // Return empty array for now
  }

  // Utility Methods
  private async flushMetrics(): Promise<void> {
    if (this.metricBuffer.length === 0) return;

    const metrics = [...this.metricBuffer];
    this.metricBuffer = [];

    try {
      // TODO: Send metrics to backend
      // This would send the metrics batch to the monitoring backend
      
      logger.debug(`Flushed ${metrics.length} metrics`, {
        metrics_count: metrics.length,
        metric_names: [...new Set(metrics.map(m => m.name))]
      });

    } catch (error) {
      logger.error('Failed to flush metrics', { data: error });
      
      // Re-queue metrics on failure (with some limit to prevent memory issues)
      if (this.metricBuffer.length < 1000) {
        this.metricBuffer.unshift(...metrics);
      }
    }
  }

  private startPeriodicFlush(): void {
    this.flushTimer = setInterval(() => {
      this.flushMetrics().catch(error => {
        logger.error('Error in periodic metric flush', { data: error });
      });
    }, this.config.flushInterval);
  }

  private extractQueryType(query: string): string {
    const normalizedQuery = query.trim().toLowerCase();
    
    if (normalizedQuery.startsWith('select')) return 'select';
    if (normalizedQuery.startsWith('insert')) return 'insert';
    if (normalizedQuery.startsWith('update')) return 'update';
    if (normalizedQuery.startsWith('delete')) return 'delete';
    if (normalizedQuery.startsWith('create')) return 'create';
    if (normalizedQuery.startsWith('drop')) return 'drop';
    if (normalizedQuery.startsWith('alter')) return 'alter';
    
    return 'other';
  }

  // Cleanup
  async destroy(): Promise<void> {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }

    // Flush any remaining metrics
    await this.flushMetrics();
  }
}

// Global monitoring client instance
let monitoringClient: MonitoringClient | null = null;

export function createMonitoringClient(config: MonitoringClientConfig): MonitoringClient {
  if (monitoringClient) {
    throw new Error('Monitoring client already initialized');
  }

  monitoringClient = new MonitoringClient(config);
  return monitoringClient;
}

export function getMonitoringClient(): MonitoringClient | null {
  return monitoringClient;
}

// High-level monitoring functions
export const monitoring = {
  recordMetric: async (name: string, value: number, type?: MetricType, labels?: Record<string, string>) => {
    const client = getMonitoringClient();
    if (client) {
      await client.recordMetric(name, value, type, labels);
    }
  },

  incrementCounter: async (name: string, labels?: Record<string, string>, value?: number) => {
    const client = getMonitoringClient();
    if (client) {
      await client.incrementCounter(name, labels, value);
    }
  },

  setGauge: async (name: string, value: number, labels?: Record<string, string>) => {
    const client = getMonitoringClient();
    if (client) {
      await client.setGauge(name, value, labels);
    }
  },

  recordResponseTime: async (endpoint: string, duration: number, statusCode: number, organizationId?: string) => {
    const client = getMonitoringClient();
    if (client) {
      await client.recordResponseTime(endpoint, duration, statusCode, organizationId);
    }
  },

  recordDatabaseQuery: async (query: string, duration: number, success: boolean, organizationId?: string) => {
    const client = getMonitoringClient();
    if (client) {
      await client.recordDatabaseQuery(query, duration, success, organizationId);
    }
  },

  recordUserActivity: async (action: string, userId: string, organizationId: string, metadata?: Record<string, any>) => {
    const client = getMonitoringClient();
    if (client) {
      await client.recordUserActivity(action, userId, organizationId, metadata);
    }
  }
};