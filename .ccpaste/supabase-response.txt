あなたは Claude Code。AIOHub 本番で /api/auth/login が 404 になっており、LoginForm が叩けないため、ダッシュボードが常に未認証で落ちています。推測で終わらせず、/api/auth/login を確実に生やして到達確認までを完了してください。

ゴール（完了条件）
 1. Production https://aiohub.jp/api/auth/login が 404 ではなくなる
 2. GET /api/auth/login は 200 or 405（とにかく “ルートが存在する” 状態）
 3. POST /api/auth/login は

 • 成功: 200 + Set-Cookie が返り、/api/health/auth-snapshot が AUTHENTICATED_READY に到達
 • 失敗: 401 + { ok:false, code, message } を返し、LoginForm は遷移しない

 4. 上記を コード側で自動検証できる（curl で機械的に確認）

⸻

Task 1: 404の原因をコードで特定（最優先）

次を全部確認して、原因を断定して直す：
 • src/app/api/auth/login/route.ts が 存在するか（大小文字含む）
 • ルートが app/api/... ではなく 別の場所（例: pages/api や src/pages）に誤配置されてないか
 • middleware.ts の matcher が /api を巻き込んで rewrite/redirect していないか（特に /api/auth/login を除外する）
 • ルートグループや構成の問題で、意図した path にビルドされていない可能性
 • Vercel の “Root Directory” がズレて 別ディレクトリをデプロイしていないか（ただし sha は health で取れているので、同一ビルド内で route が欠けている線が濃い）

⸻

Task 2: /api/auth/login に “存在確認GET” を必ず追加

POST専用だとブラウザ/DevToolsで判断が難しいので、必ず GET を実装して 200 を返す（診断用）。

例：
 • GET → { ok:true, route:"/api/auth/login", methods:["POST"] , sha, timestamp } を返す
 • POST → 既存のログイン処理

これで 404 かどうかを即判定できる。

⸻

Task 3: LoginForm が 404/401 でも勝手に遷移しない

LoginForm 側は必ず：
 • fetch('/api/auth/login') が 404/401 のときは画面にエラー表示のみ（router.push/replace 禁止）
 • 200 のときだけ /dashboard へ遷移

⸻

Task 4: 機械テストをリポジトリに入れる（ユーザーに依存しない）

npm run smoke:auth 的なスクリプトを追加して、デプロイ後に以下が確認できるようにする：
 1. ルート存在確認（404排除）

curl -i https://aiohub.jp/api/auth/login | head

期待: HTTP/2 200 or HTTP/2 405（404は禁止）
 2. supabase-env が sha を返す（既にある）

curl -s https://aiohub.jp/api/health/supabase-env | jq .sha


⸻

期待する成果物
 • 404 の原因の断定（どの設定/ファイル配置/middleware が原因かを明記）
 • src/app/api/auth/login/route.ts の修正（GET追加含む）
 • middleware が /api/auth/login を邪魔しない保証
 • smoke スクリプト追加
 • commit + push + デプロイ（sha提示）

⸻

これで「ログイン以前の段階」で詰まっている状態を終わらせます。まずは /api/auth/login の 404 をゼロにすることだけに集中して完了させてください。
